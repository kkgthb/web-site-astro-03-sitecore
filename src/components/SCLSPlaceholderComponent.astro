---
//Placeholder.astro belongs to library rather than application itself.
//But there are limitation on how Astro works with components.
//We can't call component as function: https://docs.astro.build/en/reference/errors/invalid-component-args/
//It causes dependency between Placeholder.astro and ComponentFactory.astro
//And as ComponentFactory is dynamic and could not be moved out of application, we need to keep Placeholder.astro here as well.
import SCLSComponentFactory from "./../temp/component-factory.astro";
import type {
    ComponentRendering,
    RouteData,
    HtmlElementRendering,
    Field,
    Item,
} from "@sitecore-jss/sitecore-jss/layout";

// Help invokers of <SCLSPlaceholderComponent> understand that
// it should behave differently if "normal" vs. embedded within the Sitecore Experience Editor.
export type JssDynamicComponent = ComponentRendering & {
    isxEditorComponent?: boolean;
};

// Clarify that invocations of "<SCLSPlaceholderComponent>" can instead be "<SCLSPlaceholderComponent key="value" and="so on">".
export interface Props {
    [key: string]: unknown;
    name: string;
    rendering: ComponentRendering | RouteData;
    componentFactory?: typeof SCLSComponentFactory;
    fields?: {
        [name: string]: Field | Item[];
    };
    params?: {
        [name: string]: string;
    };
    missingComponentComponent?: any;
    hiddenRenderingComponent?: any;
    errorComponent?: any;
}

// DEBUG LINE ONLY
console.log(`CONTEXT: SCLSPlaceholderComponent.  A.pks:  ${JSON.stringify(Object.keys(Astro.props))}`);
console.log(`CONTEXT: SCLSPlaceholderComponent.  A.pk-rend:  ${JSON.stringify((({ name, iscallto, calledfroma }) => ({ name, iscallto, calledfroma }))(Astro.props))}`);

// Make <SCLSPlaceholderComponent> return something "normal" vs. "Experience-Editor-friendly."
export function convertToDynamicComponents(
    components: (ComponentRendering | HtmlElementRendering)[] | undefined,
) {
    return (
        components &&
        components.map((component) => {
            const jssComponent = {
                ...component,
                //TODO: isxEditorComponent depend on experiense editor element name or type
                isxEditorComponent: false,
            } as JssDynamicComponent;

            return jssComponent;
        })
    );
}

// Make it more shorthandey to refer to whatever
// "rendering" property <SCLSPlaceholderComponent> has been given by its invoker.
const { rendering } = Astro.props;

// Build up a collection of all of the components making up the <SCLSPlaceholderComponent>.
const components = convertToDynamicComponents(
    rendering.placeholders && rendering.placeholders[Astro.props.name],
);

// Which components behave differently when viewed through the Experience Editor portal?
const isEditor =
    components &&
    components.every((component) =>
        component.isxEditorComponent ? true : false,
    );

// Determine whether there're any more Astro components to render
// that were written between <SCLSPlaceholderComponent> and </SCLSPlaceholderComponent>.
console.log(`Aks:  ${JSON.stringify(Object.keys(Astro))}`); // ["props","self"]
console.log(`A.sks:  ${JSON.stringify(Object.keys(Astro.slots))}`); // []
console.log(`A.sfks:  ${JSON.stringify(Object.keys(Astro.self))}`); // ["isAstroComponentFactory","moduleId","propagation"]
const hasChildren = await Astro.slots.has("default");
console.log(`hasChildren: ${hasChildren}`);

// Build up a collection of exactly what Astro components need to be rendered
// that were written between <SCLSPlaceholderComponent> and </SCLSPlaceholderComponent>.
const children = await Astro.slots.render("default", [components, isEditor]);
console.log(`children: ${children}`);
---

{
    (hasChildren && <Fragment set:html={children} />) ||
        (components &&
            components.map((component) => (
                <SCLSComponentFactory
                    name={component.componentName}
                    route={component}
                />
            )))
}
